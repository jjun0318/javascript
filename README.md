# javascript 변수
**변수** : 변경이 가능한 수, 변경이 가능한 데이터를 저장하고 있는 메모리 공간<br/>(한번 저장된 데이터는 계속 사용 되도 삭제되지 않음), <br/>연산된 결과를 저장하거나 연산에 필요한 데이터를 저장하는 장소, 변수에는 1개 데이터만 저장가능, 다른 데이터를 입력 시 기존 데이터는 삭제
<br/>키워드로 var(es5 방식), let(es6 방식), const(es6 방식) 를 사용함

사용법 : 
- 키워드 변수명; // 변수를 먼저 선언하고 나중에 필요에 따라서 데이터를 저장하여 사용
- 키워드 변수명 = 데이터; // 변수를 선언과 동시에 데이터를 저장하여 사용
- var a;
- var a = 100;

```
console.log("출력하고 싶은 내용 입력..");
console.log(100 + 200);
```

<br/>연산식, 연산만 진행함, 연산된 내용을 저장하지 않고 프로그램이 끝남
100 + 200;
var a = 1000 + 2000; <br/>연산된 내용을 저장
<br/>console.log(a); <br/>변수 a 에 저장된 데이터를 가져와서 화면에 출력
<br/>console.log(a + 1000); <br/>저장된 내용을 가져와서 다른 데이터와 연산

# javascript 연산자
**연산자** : 자바스크립트에서 데이터 사이의 연산을 진행하기 위해서 사용하는 기호, <br/>기본적으로 연산 방향은 왼쪽에서 오른쪽으로 이동하면서 진행

**산술연산자** : 수학에서 사용하던 4칙연산을 위한 연산자, +,-보다 *,/ 가 연산의 우선순위가 높음

```
 + : 두개의 피연산자를 더하는 연산자
 - : 두개의 피연산자를 사용하여 하나의 피연산자에서 다른하나의 피연산자를 빼는 연산자
 * : 두개의 피연산자를 사용하여 서로 곱하는 연산자
 / : 두개의 피연산자를 사용하여 하나의 피연산자를 다른 하나의피연산자로 나누는 연산자
 % : 두개의 피연산자를 사용하여 하나의 피여산자를 다른 하나의피연산자로 나눈 후 그 나머지를 가져오는 연산자
var a = 10;
var b = 3;
var c = a + b;
console.log(c);
```
<hr/>

**할당연산자** : 변수에 데이터를 저장하기 위한 연산자, 산술연산자와 합하여 사용이 가능함, 연산의 방향이 오른쪽에서왼쪽으로 실행됨, 연산의 우선 순위가 가장 낮음
```
 = : 데이터를 변수에 저장
 +=, -=, *=, /=, %= : 산술 할당 연산자, 산술 연산자의 기능과할당 연산자의 기능을 동시에 가지고 있음
c = c + 1;
console.log(c);
c += 1;
console.log(c);
```
<hr/>

**비교연산자** : 2개의 데이터를 비교하여 그 결과를 알려주는연산자, 숫자와 문자열 모두 사용 가능
```
 < : 연산자의 왼쪽을 기준으로하여 왼쪽의 피연산자가 오른쪽의피연산자보다 작을 때 true 아니면 false 출력
 > : 연산자의 왼쪽을 기준으로하여 왼쪽의 피연산자가 오른쪽의피연산자보다 클 때 true 아니면 false 출력
 <= : 연산자의 왼쪽을 기준으로하여 왼쪽의 피연산자가 오른쪽의피연산자보다 작거나 같을 때 true 아니면 false 출력
 >= : 연산자의 왼쪽을 기준으로하여 왼쪽의 피연산자가 오른쪽의피연산자보다 크거나 같을 때 true 아니면 false 출력
 == : 두 피연산자의 값이 서로 같으면 true 다르면 false 출력
 != : 두 피연산자의 값이 서로 다르면 true 같으면 false 출력
```
<hr/>

**논리연산자** : 논리적으로 참인지 거짓인지를 판단하는 연산자
```
 && : 논리곱연산, 연산자를 기준으로 두 피연산자가 모두 true이면 최종 결과가 true, 두 피연산자 중 하나라도 false이면 최종결과가 false, 
 || : 논리합연산, 연산자를 기준으로 두 피연산자 중 하나라도true 이면 최종 결과가 true, 모두 false 일 경우 최종 결과가false, 
 ! : 논리부정연산, 단한연산자로 연산자 뒤의 결과를 반대로변경함, true -> false, false -> true,
```
<hr/>

**단항연산자** : 연산 시 1개의 피연산자를 사용하는 연산자
```
 ! : 논리 부정 연산자, 결과값을 반대로 변경하는 연산자
 ++ : 지정된 피연산자의 값을 1 올리는 연산자
 -- : 지정된 피연산자의 값을 1 내리는 연산자
 ++, --는 피연산자의 앞, 혹은 뒤에 붙여서 사용
 피연산자의 앞에 붙었을 때와 뒤에 붙었을 때 실제로 연산이수행되는 시점이 다름
 ++, --는 피연산자에 단독으로 사용 시 앞에 있으나 뒤에 있으나동일한 결과가 출력됨
 ++, --가 다른 연산식과 함께 사용 시 ++, --의 위치에 따라서결과가 달라짐
 다른 연산식과 함께 사용 시 변수 앞에 ++, --가 있으면 ++,--를 먼저 수행하고 다른 연산식을 실행함
 다른 연산식과 함께 사용 시 변수 뒤에 ++, --가 있으면 다른연산식을 먼저 수행하고, ++, --를 수행함
```
<hr/>

**삼향연산자** : 연산 시 3개의 피연산자를 사용하는 연산자
```
 연산식 ? 참일경우:거짓일경우 : 연산식의 결과가 논리적으로true 인지 false 인지를 판단하여 실행하는 소스코드를 선택할 수있는 연산자
 제어문의 if ~ else 문으로 100% 대체 가능하기 때문에프로그래밍 초반에는 사용하지 않아도 상관없음
 삼항연산자를 if ~ else 문으로 대체
if (a > 20) {
    console.log("a는 20보다 크다.");
}
else {
    console.log("a는 20보다 적다.");
}
```
<hr/>

**유형연산자** : 데이터 타입이 맞는지 아닌지를 확인하는 연산자
```
 직접 생성한 데이터가 아닌 다른 곳에서 전달된 데이터를사용하고자 할 경우 사용하고자 하는 데이터 타입의 유형을 정확히알아야 오류가 발생하지 않음, 데이터 타입의 종류를 확인하기위해서 사용하는 연산자
 typeof : 변수에 저장된 데이터가 사용자가 지정한 데이터타입이 맞는지 확인(true/false)
 instansof : 변수에 저장된 데이터(객체)가 사용자가 지정한데이터 타입(클래스)이 맞는지 확인(true/false)
```
<hr/>

**비트연산자** : 2진수 연산 시 사용, 자바스크립트에서는 비트연산을 사용하는 경우가 거의 없음
```
 >>, << : 2진수 연산 시 비트 이동을 하는 연산자

연산자 우선순위

 연산자는 동시에 사용 시 먼저 동작하는 우선 순위가 존재함
 기본적으로 연산은 왼쪽에서 오른쪽으로 이동하면서 진행함
 () 사용했을 경우 가장 먼저 () 안의 내용을 연산함
        
 괄호() -> 단항연산자 (++, --, !) -> 산술 연산자(*, /, %, +,-) -><br/> 비교 연산자(<, >, <=, >=, ==, !=) -> 논리 연산자(&&, ||)-> 할당 연산자(=, +=) 우선 순위 나열한거
```
# javascript 이스케이프 문자

**이스케이프 문자**

문자열 안에서 입력되고 특정한 기능을 하는 문자 <br/>
문자열 안에서 '\'와 함께 지정한 문자를 입력할 경우 이스케이프 문자로 지정된 문자의 기능이 동작함
```
 \' : 문자로써 작은 따옴표(') 를 사용하고자 할 경우 사용
 \" : 문자로써 큰 따옴표(") 를 사용하고자 할 경우 사용
 \\ : 문자로써 역 슬래시(\) 를 사용하고자 할 경우 사용
 \n : 줄 바꿈 문자
 \t : tab 기능
 \f : 폼피드 (사용안함)
 \r : 리턴키 (사용안함)
 \b : 백스페이스 (사용안함)
 \v : 세로 tab 기능 (사용안함)
```


# javascript 데이터타입

**데이터 타입** : 자바스크립트를 통해서 프로그래밍 시 데이터를 연산 및 저장하기 위해서 사용하는 데이터를 구분하는 단위를 데이터 타입이라 함

 자바스크립트에서는 기본적으로 사용되는 데이터 타입을 6가지로 구분함

 기본 데이터 타입
- 숫자형(Int)
- 문자열형(String)
- 논리형
- null
- undefined

 객체 타입
- object 타입
- array 타입
- date 타입

 **숫자형 타입(number)** <br/>
 정수와 실수를 모두 지칭하는 데이터 타입
 연산에 사용 함
기호 없이 그대로 정수 혹은 실수를 입력하면 됨
 내부적으로는 정수와 실수를 구분하지만 사용자는 구분하지 않음
 <br/>ex) 100, 200, 10 + 20, 5.5, 100.0, 3.14 * 10.0

 **주의사항**
```
<br/> 정수와 실수를 연산 시 결과 값은 실수로 출력됨
<br/> 정수와 실수의 데이터 타입 크기를 비교 시 실수가 데이터 타입이 더 큼
<br/> 정수와 실수를 연산 시 모두 실수로 변환 후 연산을 진행하고 결과를 실수로 출력함
<br/>데이터의 유실이 발생되지 않음
```
<hr/>

**문자열 타입(string)**
```
 자바스크립트에서 텍스트를 표시하기 위한 데이터 타입
 문자 및 문자열을 통합하여 문자열 타입으로 사용함
 "" 혹은 '' 안에 있는 모든 데이터를 문자열이라고 함
 "", '' 사용 시 시작 기호가 "이면 종료 기호도", 시작 기호가 '이면 종료 기호도' 이어야 함
 "" 사용 시 "" 내부에 '' 사용 가능
 '' 사용 시 '' 내부에 "" 사용 가능
 + (문자열 연결연산자) 기호를 사용하여 두개의 문자열을 하나의 문자열로 연결할 수 있음
 문자열과 다른 데이터 타입을 연산 시 연산이 불가능하기 때문에 둘다 문자열로 변경하여 하나의 길다란 문자열로 연결함
```
<hr/>

**논리형 타입** <br/>
데이터를 논리적으로 참인지 거짓인지를 구분하는 데이터 타입 <br/>
true, false 2가지 값만 가지고 있음 <br/>
문자열이 아닌 자체적인 데이터 타입이기 때문에 "" 나 '' 를 사용하지 않고 true, flase를 입력 <br/>
주로 데이터 비교 시 사용함<br/>

**예시**
```
var b1 = true;
var b2 = false;
console.log(10 < 5); // 결과값 flase
console.log(10 > 5 || 20 > 10); // 논리 연산 결과값 true
if (10 > 5) {
    console.log("10이 5보다 크다");
}
else {
    console.log("10이 5보다 크지 않다");
}
```
자바스크립트에서 true 인 값과 false인 값 <br/>
 true : 숫자 0이 아닌 모든값, 숫자 0.0이 아닌 모든 값, 빈 문자열이 아닌 모든 문자열,true <br/>
 false : 숫자 0, 숫자 0.0, 숫자 -0, 빈 문자열 "", 빈 문자열 '', null, undefind, false, NaN <br/>
 Boolean(데이터) : 결과값을 논리형 타입으로 변환하는 함수

**null, undefined** <br/>
 데이터가 없다는 의미의 데이터 타입
 데이터가 존재하지 않기 때문에 연산이 불가능함
- null : 데이터가 없음, 변수에 기존의 데이터를 저장하여 사용한 후 데이터가 비어 있는 상태
- undefined : 데이터가 없음, 변수를 선언한 후 데이터를 한번도 저장하지 않은 상태, 변수를 선언만 하고 데이터를 저장하지 않으면 undefined 상태가 됨

**예시**
```
var value; // undefined 상태
console.log(value); // undefined 상태
console.log(value + 100); //undefined는 숫자가 아니기 때문에 숫자와 연산이 불가능함 그래서 NaN으로 표시됨
console.log(value + "문자열");
value = 100; // 데이터가 저장된 상태
console.log(value);
console.log(value + 100); // value에 100이 저장되어 있기 때문에 연산 가능
value = null; // 데이터가 없는 빈 상태, null인 상태
console.log(value); // value가 null인 상태
console.log(value + 100); // value의 값이 null이고 숫자와 연산 시 숫자만 출력 
```
<hr/>

**Object 타입**
자바스크립트 객체 타입으로 한번에 여러개의 데이터를 저장할 수 있는 데이터 타입
 베열 타입 (array)
- 하나의 변수명으로 여러개의 데이터를 저장할 수 있는 데이터 타입
- 여러개의 데이터를 구분하기 위해서 index 를 사용함 (0부터 시작)
- 여러가지 데이터 타입을 동시에 저장할 수 있음
- 사용 기호는 [] 이고, [] 안에 index 번호를 입력하여 사용함
- 자바스크립트의 배열은 배열의 크기가 커졌다가 줄었다가 할 수 있음(자바에서는 불가능)
```
 사용법 : 선언
 1. var array = [1, 2, 3, 4, 5]; // 배열 선언과 동시에 데이터를 추가, 추천하는 방식
 2. var array = new Array(1, 2, 3, 4, 5); // 배열 선언과 동시에 데이터 추가, new 키워드를 사용하여 배열 생성
 3. var array = []; // 배열을 선언만 하고 데이터는 저장하지 않음, 빈 배열만 생성
 사용법 : 사용
 array[1] = 100; // 데이터 저장
 array[2]; // 데이터 출력
var array1 = [10, 20, 30, 40, 50]; // 자바스크립트에서 추천하는 방식
        console.log(array1);
        console.log(array1[0]);
        console.log(array1[1]);
        console.log(array1[2]);
        console.log(array1[3]);
        console.log(array1[4]);
        array1[2] = 300;
        array1[4] = 500;
        console.log(array1[2]);
        console.log(array1[4]);
```
자바스크립트의 변수는 데이터 추론 방식을 사용 <br/>
- 저장된 데이터 타입에 따라서 변수의 타입이 결정됨
-  자바스크립트의 변수는 모든 데이터 타입을 저장할 수 있음
- 이미 선언되고 사용된 변수에서도 모든 데이터 타입을 저장할 수 있음
- 변수에 함수 및 객체도 저장 가능
<hr/>

**다차원 배열** <br/>
- 일반적인 배열을 1차원 배열이라고 함
- 1차원 배열은 배열의 요소가 일반 데이터인 배열
- 2차원 배열은 배열의 요소가 1차원 배열인 배열
- 3차원 배열은 배열의 요소가 2차원 배열인 배열
- 사용시 [] 의 수에 따라 1차원, 2차원, 3차원 배열로 구분함
- 2차원 배열의 기준으로 앞의 []가 행을 뜻하고 뒤의 []가 열을 뜻함 <br/>

**사용법(선언)** <br/>
1. var array = [ [10, 20, 30], [40, 50, 60], [70, 80, 90] ]; // 2차원 배열
2. var array = [ [ [10, 20,], [30, 40] ], [ [50, 60], [70, 80] ] ]; // 3차원 배열 <br/>

**사용법(입력, 출력)** <br/>
1. array[1][2] = 100; // 2차원 배열의 1행 2열에 데이터 입력
2. array[1][2]; // 2차원 배열의 1행 2열의 값을 출력
```
1차원 배열 선언
        var tp1Arr = [10, 20, 30, 40, 50];
        console.log(tp1Arr);

        2차원 배열
        var tp2Arr = [
            [10, 20, 30, 40, 50],
            [60, 70, 80, 90, 100],
            [110, 120, 130, 140, 150]
        ]; 
        console.log(tp2Arr);

        3차원 배열
        var tp3Arr = [
            [
                [10, 20, 30],
                [40, 50, 60], 
                [70, 80, 90]
            ],
            [
                [100, 110, 120], 
                [130, 140, 150], 
                [160, 170, 180]
            ]
        ];
        console.log(tp3Arr);

        var bingo = [
            [1, 2, 3, 4, 5],
            [6, 7, 8, 9, 10],
            [11, 12, 13, 14, 15],
            [16, 17, 18, 19, 20],
            [21, 22, 23, 24, 25]
        ];
```
<hr/>

**객체 타입 (object)**
- 배열과 같이 하나의 변수명으로 여러가지 데이터를 저장할 수 있는 데이터 타입
- 자바의 class 및 object 와 동일한 개념
- 데이터를 저장하는 개념으로만 사용할 경우의 데이터 타입
- 사용 기호는 {}를 사용하고, 데이터를 구분하기 위한 key와 실제로 데이터를 저장하는 value 부분으로 나누어짐
- key와 value는 ':' 을 사용하여 구분, 각각의 데이터를 ',' 를 사용하여 구분함
- 배열과 달리 index가 없음 (저장되는 순서가 없음)
- value는 중복 가능, key는 중복 불가
- object 의 데이터 사용 '.' 혹은 ["key명"] 을 사용하여 '변수명.key명', '변수명["key명"]' 형태로 사용 <br/>

**사용법(선언)**
- var obj = {key1:value1, key2:value2, key3:value3}; //object 타입 선언과 동시에 데이터 저장
- var obj = {}; // object 타입을 선언만 함, 빈 object 타입 선언 <br/>

**사용법(입력, 출력)**
- obj.key1 = 100; // object 타입의 변수 obj가 가지고 있는 key 중 key1 에 데이터 입력
- obj["key1"] = 100; // object 타입의 변수 obj가 가지고 있는 key 중 key1에 데이터 입력
- obj.key1; // object 타입의 변수 obj가 가지고 있는 key 중 key1의 value를 출력
- obj["key1"]; // object 타입의 변수 obj가 가지고 있는 key 중 key1의 value를 출력

**예제(사용법)**
```
var obj = {"key1":"value1", "key2":"value2", "key3":"value3"};
        console.log(obj);
        console.log(obj.key1);
        console.log(obj.key2);
        console.log(obj.key3);
        obj.key1 = "object 타입";
        obj.key2 = "데이터만 사용할 경우";
        obj.key3 = "object 타입이라고 함";
        console.log(obj);
        console.log(obj["key1"]);
        console.log(obj["key2"]);
        console.log(obj["key3"]);
```
<hr/>

**배열과 object의 차이점** <br/>
        <br/>배열은 비슷한 유형의 데이터를 여러개 저장하기 위해서 주로 사용 <br/>
        object 타입은 하나의 물체 혹은 개체의 여러가지 특징을 한 곳에 저장하기 위해서 사용

**예제**
```
        var objCar = {name: "토레스 evx", type: "SUV", size: "중형", price: 4550}
        console.log(objCar.name);
        console.log(objCar.type)
        console.log(objCar["size"]);
        console.log(objCar["price"]);

        var arrCar = ["토레스 evx", "SUV", "중형", 4550]
        console.log(arrCar[0]);
        console.log(arrCar[1]);
        console.log(arrCar[2]);
        console.log(arrCar[3]);

        var objHyundaiCar = [
            {name: "그랜저", cc: 3000, type: "세단", size: "대형", price: 3743},
            {name: "소나타", cc: 2000, type: "세단", size: "중형", price: 2808},
            {name:"팰리세이드", cc: 3000, type: "SUV", size: "대형", price: 3800}
        ];
        console.log(objHyundaiCar);
```

**object 사용 시 데이터 수정, 추가 key 입력** <br/>
- 수정은 기존의 key명을 그대로 사용하여 데이터 저장
- 기존에 없는 key 및 value를 추가할 경우 '변수명.새key명 = 데이터' 으로 사용 <br/>
**예제** <br/>
```
console.log("원본 objCar 의 정보 : "); <br/>
console.log(objCar); <br/>
objCar.gas = "전기"; <br/>
console.log(objCar); 
```

**keys(), values()** <br/>
- keys() : 지정한 object 타입의 변수가 가지고 있는 모든 key를 가져옴
- values() : 지정한 object 타입의 변수가 가지고 있는 모든 value를 배열로 가져옴 <br/>
**사용법**
 var arrKeys = Object.keys(object 타입 변수); <br/>
 var arrValues = Object.values(object 타입 변수); <br/>

 **예제**
 ```
        var mouse = {type: "로지텍 POP mouse", type: "블루투스", button: 4, price: 30000, func: "이모지입력"};
        console.log(mouse.name);
        console.log(mouse.type);
        console.log(mouse.price);

        var keys = Object.keys(mouse);
        console.log(keys);
        var values = Object.values(mouse);
        console.log(values);
```

**다차원 object 타입** <br/>
다차원 배열과 동일하게 object 타입의 요소로 object 타입을 사용하는 것

**2차원 object 타입**
```
        var hyundaiCar = {
            bus: {name: "솔라티", gas: "디젤", color: "회색"},
            bigtruck: {name: "마이티", gas: "디젤", color: "흰색"},
            truck: {name: "포터2", gas: "디젤", color: "파랑색"},
            mpv: {name: "스타리아", gas: "가솔린", color: "검정색"}
        };
```
# javascript 배열 관련 함수
**length** <br/>
 length : 배열의 크기를 알려주는 명령어 <br/>
- 사용법
- var size = arr.length; 

**예제**
```
        var fruits = ["바나나", "사과", "딸기", "복숭아", "참외"];
        console.log(fruits);
        var size = fruits.length; // 지정한 배열의 크기를 출력
        console.log("배열 fruits 의 크기는 : " + size);
        console.log("배열 fruits 의 크기는 : " + fruits.length);
```
**toString** <br/>
toString() : 배열에 저장된 모든 데이터를 문자열로 출력함 <br/>
- 사용법
-  var str = arr.toString();

**예제**
```
        fruits = ["바나나", "사과", "딸기", "복숭아", "참외"];
        console.log(fruits);
        // toString()으로 모든 내용 출력 시
        var str = fruits.toString();
        console.log("배열 fruits에 저장된 내용 : " + str);
        console.log("배열 fruits에 저장된 내용 : " + fruits.toString());
        // 사용자가 직접 내용 출력 시
        str = "";
        str = fruits[0];
        str = str + fruits[1];
        str = str + fruits[2];
        str = str + fruits[3];
        str = str + fruits[4];
        console.log(str);
```
**Join** <br/>
join() : toString()과 동일한 기능을 제공함, ',' 대신 지정한 문자로 데이터를 구분함
- 사용법
- var str = 베열명.join();
- var str = 베열명.join("구분할문자");

**예제**
```
        console.log("\n ----- join -----\n ")
        var fruits = ["바나나", "사과", "딸기", "복숭아", "참외"];
        console.log(fruits.join());
        console.log(fruits.join("*"));
        console.log(fruits.join("!@#$%"));
```
<hr/>

**기존 배열에 데이터 추가/삭제하기** <br/>
push() : 기존 배열의 가장 마지막에 데이터를 추가
- 사용법
- 배열명.push(추가할 데이터);

 pop() : 기존 배열의 가장 마지막 데이터를 삭제, 삭제한 데이터를 출력
- 사용법
- 배열명.pop();
- var 변수명 = 배열명.pop();
<hr/>

**배열 합하기** <br/>
concat() : 여러개의 배열을 하나의 배열로 합하는 명령어 <br/>
기존 배열에 여러개의 배열이 추가되는 것이 아니라 기존 배열의 뒷 부분에  <br/> 다른 배열을 추가하여 새로운 배열로 만듬, 원본은 그대로 유지
- 사용법
- 배열1.concat(배열2);
- 배열1.concat(배열2, 배열3);
<hr/>

**배열의 내용 수정하기** <br/>
**splice** <br/>
splice() : 기존 배열의 내용을 수정할 수 있음, 원본의 내용을 수정 <br/>
2번째 매개변수인 삭제할 수를 0으로 사용하면 원하는 위치에 데이터를 추가 <br/>
2번째 매개변수인 삭제할 수를 1이상 지정하고, 3번째 매개변수는 추가할 데이터를 추가하지 않으면 원하는 위치의 데이터를 삭제함 <br/>
2번째 매개변수인 삭제할 수와 3번째 매개변수인 추가할 데이터의 개수가 같으면 원하는 위치의 데이터를 수정함
- 사용법
- 배열명.splice(수정할 index, 삭제할 수, 추가할 데이터);

**slice** <br/>
slice() : 기존 배열의 내용을 수정할 수 있음, 원본은 그대로 두고 수정된 내용을 새로운 배열로 만들어 출력, 원본은 그대로 유지 <br/>
2번째 매개변수를 생략 가능함, 2번째 매개변수 생략 시 1번째 매개변수의 위치부터 마지막까지 데이터를 복사함 <br/>
복사할 종료 index는 포함하지 않고 그 앞의 index까지만 복사 <br/>
- 사용법
- 배열명.slice(복사할 시작 index, 복사할 종료 index);

# javascript 제어문
제어문 : 소스코드를 실행 중 조건의 결과에 의해서 실행 흐름을 변경할 수 있는 명령어 <br/>
- 제어문, 반복문으로 나눔
- 제어문에는 if, switch 2가지가 존재함

    + if문 : 조건식의 결과가 참일 경우에 소스코드를 실행하는 방식의 명령어

    + 단순 if : 조건식의 결과가 참(true)일 경우 소스코드를 추가적으로 실행하는 방식
    + 조건식의 결과가 거짓(false)일 경우 추가적으로 실행하는 코드는 없음, 기존 소스코드 그대로 실행

- 사용법
- if (조건식) {
-   조건식의 결과가 true 일 경우 실행할 소스코드...
- }

**단순 if문 사용 시(예제)**
```
    var money = 15000;

    console.log("중화요리점에 갑니다.");
    console.log("자장면을 주문합니다.");

    // 조건식의 결과가 true 일 경우에만 실행
    if (money >= 12000) {
      console.log("군만두를 추가 주문합니다.");
    }

    console.log("주문한 음식을 맛있게 먹습니다.");
```
<hr/>

**if else 문** <br/>
- if ~ else : 조건식의 결과에 따라서 실행하는 소스코드가 변경되는 방식
    + 조건식의 결과가 참(true)일 경우 실행되는 소스코드와 거짓(false)일 경우 실행되는 소스코드가 다름
    + 무조건 두 가지 경우 중 한가지를 선택해서 실행해야 함
- 사용법
- if (조건식) {
-    조건식의 결과가 true 일 경우 실행할 소스코드 ...
- }
- else {
-    조건식의 결과가 false 일 경우 실행할 소스코드 ...
- }

**if else문 사용 시(예제)**
```
    console.log("----- if ~ else 문 사용 시 -----");
    var rain = false;

    console.log("중화요리점에 갑니다.");
    console.log("밖에 비가 오나요?");

    if (rain == true) {
      console.log("삼선짬뽕을 주문합니다.");
    }
    else {
      console.log("자장면을 주문합니다.");
    }

    console.log("주문한 음식을 맛있게 먹습니다.");
```
<hr/>

**alert, confirm, prompt** <br/>
- alert(); // 사용자에게 알림
- confirm(); // 사용자에게 둘(yes/no) 중 하나 선택 요청
- prompt(); // 사용자에게 데이터를 입력받기

- prompt() 사용 시 매개변수를 2개 사용할 수 있음
- 2번째 매개변수를 사용자가 입력할 데이터의 기본값이 됨
- 사용자가 입력한 모든 데이터를 문자열로 인식하여 가져옴
<hr/>

**else if 문** <br/>
- if ~ else if ~ else : 조건식을 여러개 사용할 수 있는 방식
    + 조건식이 위에서 아래로 순차적으로 적용하여 조건식의 결과가 true 인 블록의 소스코드를 실행
    + 마지막에 들어가는 else 문은 생략이 가능함
- 사용법
- if (조건식 1) {
   조건식 1의 결과가 true 일 경우 실행할 소스코드 ...
 }
- else if (조건식 2) {
   조건식 2의 결과가 true 일 경우 실행할 소스코드 ...
}
- else if (조건식 3) {
   조건식 3의 결과가 true 일 경우 실행할 소스코드 ...
}
...
- else {
   모든 조건식의 결과가 true 가 아닐 경우 실행할 소스코드 ...
}

**else if문 사용 시(예제)**
```
    console.log("중국요리점에 갑니다.");
    console.log("메뉴를 선택합니다.");

    var food = prompt("주문할 메뉴를 입력하세요.");

    if (food == "자장면") {
      console.log("자장면을 주문합니다.");
    }
    else if (food == "짬뽕") {
      console.log("짬뽕을 주문합니다.");
    }
    else if (food == "볶음밥") {
      console.log("볶음밥을 주문합니다.");
    }
    else if (food == "잡채밥") {
      console.log("잡채밥을 주문합니다.");
    }
    else {
      console.log("우동을 주문합니다.");
    }
    
    console.log("주문한 음식을 맛있게 먹습니다.");
```
**else if 문 사용 시 주의 사항
조건식에 사용할 데이터는 순차적으로 사용해야 함**

**switch 문** <br/>
if 문과 같은 제어문의 한 종류<br/>
조건식에 해당 하는 값을 가지고 있는 case 블록의 소스코드를 실행하는 방식 <br/>
- 사용법
- switch (조건식) {
  +  case 값1 :
  +  조건식의 결과가 case 의 값과 같을 경우 실행할 소스코드 ...
  +  break;
  +  case 값2 :
  +  조건식의 결과가 case 의 값과 같을 경우 실행할 소스코드 ...
  +  break;
  +  case 값3 :
  +  조건식의 결과가 case 의 값과 같을 경우 실행할 소스코드 ...
  +  break;
  +  ...
  +  default:
  +  조건식의 결과가 case 의 값과 일치하는 것이 없을 경우 실행할 소스코드
  +  break;
- }

**switch문 사용(예제)**
```
switch (dayOfWeek) {
            case 1:
                console.log("월요일");
                break;

            case 2:
                console.log("화요일");
                break;

            case 3:
                console.log("수요일");
                break;

            case 4:
                console.log("목요일");
                break;

            case 5:
                console.log("금요일");
                break;

            case 6:
                console.log("토요일");
                break;

            default:
                console.log("일요일");
                break;
}
```

**switch ~ case 문 사용 시 주의점**
 1. 조건에 지정된 값을 입력하는 방식
 2. case 문의 끝에 반드시 break; 문을 입력해야 함
 3. default 문은 생략 가능함
 4. switch ~ case 문 사용 시 break;를 생략하게 되면 지정한 case 부터 break;를 만날 때까지 계속 실행

 if 문과 switch ~ case 문의 차이점 <br/>
 if문은 조건식에 범위를 설정할 수 있음 <br/>
 switch ~ case 문의 조건식에는 고정된 값을 사용함 <br/>

 **if문이 switch ~ case 문을 100% 대체 가능**
 ```
        var dayOfWeek = today.getDay();

        if (dayOfWeek == 1) {
            console.log("오늘은 월요일");
        }
        else if (dayOfWeek == 2) {
            console.log("오늘은 화요일");
        }
        else if (dayOfWeek == 4) {
            console.log("오늘은 목요일");
        }
        else if (dayOfWeek == 5) {
            console.log("오늘은 금요일");
        }
        else if (dayOfWeek == 6) {
            console.log("오늘은 토요일");
        }
        else    {
            console.log("오늘은 일요일");
        }
```

> new Date() : 자바스크립트에서 기본 제공하는 날짜 관련 클래스, new 키워드와 함께 사용 시 현재 날짜를 출력함 <br/>
> getFullYear() : Date() 를 통해서 생성된 날짜를 기준으로 년도를 출력함 <br/>
> getMonth() : Date() 를 통해서 생성된 날짜를 기준으로 월을 출력함 <br/>
> getDate() : Date() 를 통해서 생성된 날짜를 기준으로 일을 출력함 <br/>
> getDay() : Date() 통해서 생성된 날짜를 기준으로 하여 일주일 중 지정한 날짜의 요일을 0 ~ 6 까지의 숫자로 출력 <br/>
> 0 : 일요일, 1 : 월요일, 6 : 토요일
```
        var today = new Date();
        var dayOfWeek = today.getDay();
        console.log("오늘 날짜는 : " + today);
        console.log("오늘 요일은 : ");


        var dayOfWeek = new Date().getDay();
```
# javascript 반복문
반복 조건이 참(true) 일 경우 지정한 소스코드를 반복 실행하는 명령어
 for문, while문 2가지 형태가 존재함

**while 문** <br/>
반복 조건이 참(true) 일 경우 코드 블럭 안의 내용을 반복 실행하는 명령어 <br/>
while 문에서 사용하는 초기화 변수를 while문 외부에서 선언하고 while문 내부에서 사용함 <br/>
while 문에서 탈출할 수 있는 조건을 while문에 지정해야 함 <br/>
무한 반복이 발생할 수 있음 <br/>
증감식의 위치에 따라서 출력되는 결과가 다르게 나올 수 있음 <br/>
반복 조건의 결과가 처음부터 false이면 while문의 반복 실행 소스코드를 한번도 실행하지 않음 

- 사용법
- 초기화 변수 선언
- while(반복조건) {
  + 반복 실행할 소스코드 ...
  + 증감식 
- }

**while문 사용(예제)**
```
        console.log("나무꾼이 나무를 합니다.");
        
        var count = 0; // 초기화 변수

        while (true) {
            count++;
            console.log("도끼로 나무를 " + count + "번 찍습니다.");

            if (count >= 10) {
                console.log("나무가 넘어갑니다.");
                break;
            }
        }
```

**주의 사항**
1. while문은 탈출 조건을 지정하지 않거나, 잘못된 반복 조건을 사용 시 무한 반복에 빠질 수 있음
2. 증감식을 생략 시 무한 반복에 빠질 수 있음
3. 증감식의 위치에 따라 출력되는 결과가 다르게 나올 수 있음
4. while문은 초기화 변수를 while문 외부에 선언하고 while문 내부에서 사용하기 때문에 while문을 2개 이상 연속으로 사용 시 초기화 변수의 이름이 같을 경우 초기화 변수의 초기값을 while문의 조건식에 맞도록 초기화해서 사용해야 함
5. while 문에서 증감식은 보통 코드 블럭의 가장 처음이나 가장 마지막에 입력함
<hr/>

**do ~ while문** <br/>
while 문은 조건식의 결과가 처음부터 false 이면 while문의 코드블록을 한번도 실행하지 않음 <br/>
do ~ while 문은 조건식의 결과가 처음부터 false 이라도 무조건 한번은 코드 블록을 실행하는 형태의 while문 <br/>
do~ while 문은 조건식이 코드 블럭보다 뒤에 있기 때문에 무조건 한번은 코드 블록을 실행함 <br/>

- 사용법
- do { <br/>
      반복 실행할 소스코드 <br/>
      증감식 <br/>
 } while (조건식);
 **do ~ while문 사용(예제)**
```
        console.log("첫번째 do ~ while 문");
        var count = 0; // do ~ while의 초기화 변수 선언 및 초기화

        do {
            console.log("count : " + count);
            count++;
        } while (count < 10);

        console.log("첫번째 do ~ while 문");

        do ~ while의 초기화 변수 선언 및 초기화가 없이 기존의 초기화 변수를 재활용함

        do {
            console.log("count : " + count);
            count++;
        } while (count < 10);
```
<hr/>

**for 문** <br/>
 가장 일반적으로 사용되는 반복문 <br/>
 기본 for문, for ~ in문, for ~ of문 3가지가 존재함 <br/>
 while문과 달리 초기화 변수, 반복 조건, 증감식을 모두 한 곳에서 입력함 <br/>
 for 문의 초기화 변수는 해당 for 안에서만 사용되고, 메모리에서 삭제 됨 <br/>
 코드 블럭 안에는 반복 실행할 소스코드만 입력하면 됨 <br/>
 반복 실행할 횟수가 정해져 있을 경우 많이 사용함 (무한 반복의 가능성이 낮음)

- 사용법
- for (초기화변수 선언, 반복 조건, 증감식) { <br/>
      반복 조건이 true일 때 반복 실행할 소스코드 ... <br/>
 }

 **for 문 사용(예제)**
```
      console.log("첫번째 for문");

      for (var i = 0; i < 10; i++) {
        console.log("i의 값 : " + i);
      }

      console.log("두번째 for문");

      for (var i = 0; i < 10; i++) {
        console.log("i의 값 : " + i);
      }
```

**중복 for문** <br/>
for문 안에 for문을 사용하는 방식 <br/>
밖의 for문이 1번 실행될 때, 안의 for문은 전체 실행됨
**중복 for문 사용(예제)**
```
    console.log("\n ----- 중복 for문 ----- \n");

    for (var i = 0; i < 5; i++) {
        for (var j = 0; j < 5; j++) {
            console.log("i의 값 : " + i + ", \tj의 값 : " + j);
        }
    }
```

반복문과 배열을 함께 사용하여 배열의 내용을 쉽게 출력할 수 있음
```
    var arrNum = [10, 20, 30, 40, 50];

    for (var i = 0; i < arrNum.length; i++) {
        console.log(arrNum[i]);
    }
```

2차원 배열의 내용을 반복문(for문)으로 출력하기 <br/>
1차원 배열의 내용을 모두 출력할때는 일반 반복문을 사용하면 쉽게 처리할 수 있음 <br/>
2차원 배열의 내용을 모두 출력할 때는 중첩 반복문을 사용하여 쉽게 처리할 수 있음 <br/>
```
    var arrNum2 = [
        [1, 2, 3, 4, 5],
        [6, 7, 8, 9, 10],
        [11, 12, 13, 14, 15],
        [16, 17, 18, 19, 20],
        [21, 22, 23, 24, 25]
    ];

    for (var i = 0; i < arrNum2.length; i++) {
        // console.log(arrNum2[i]);
        var temp = arrNum2[i];
        for (var j = 0; j < temp.length; j++) {
            console.log(temp[j]);
        }
    }
```
# javascript 함수
**함수** <br/>
- 사용자가 원하는 결과를 출력할 수 있도록 특정 작업을 수행하기 위한 여러개의 연산식을 하나의 이름으로 모아둔 코드 블록
- 키워드 function을 사용하여 함수를 선언, 선언 시에는 연산이 수행되지 않음
- 함수명 뒤에 ()를 사용하여 지정한 함수를 호출하여 실행함
- 함수 호출 시 함수의 이름과 매개변수의 개수가 동일한 함수를 호출하여 실행함
- 함수 안에 return 키워드가 있을 겨우 return 키워드 뒤의 데이터를 함수를 호출했던 곳으로 되돌려줌
- 한번 선언한 함수는 계속 재활용할 수 있음,
- 소스코드를 재활용할 수 있기 때문에 소스코드가 간략해 짐 유지보수가 편해짐
- 오류 발생한 부분을 쉽게 특정할 수 있기 때문에 유지보수가 편리함
- 함수 선언 시 하나의 함수는 하나의 기능을 가지도록 작성하는 것이 좋음 (재활용하기 쉬움)

- 매개변수 : 함수 실행 시 필요한 데이터를 함수 외부에서 전달받기 위한 변수
- 변환값 : 함수 실행 후 그 결과를 함수를 호출한 곳으로 되돌려주는 데이터

**사용법 (선언)** <br/>
- function 함수명(매개변수1, 매개변수2, ...) { <br/>
  + 함수 호출 시 실행할 소스코드 ... <br/>
  + return 함수 실행 후 되돌려줄 데이터 
- }

**사용법 (호출)**
  + 함수명(매개변수1, 매개변수2, ...);
  + var 변수명 = 함수명(매개변수1, 매개변수2, ...);


**함수의 종류 4가지** <br/>

함수는 매개변수와 반환값의 여부에 따라서 총 4가지 형태를 가지고 있음

1. 매개변수와 반환값이 모두 없는 타입
- 매개변수가 없기 때문에 함수를 실행하는데 필요한 변수를 함수 내부에서 모두 선언하고 사용하고 삭제함
- 함수 내부에서 변수가 선언되고 사용되기 때문에 데이터가 고정되어 있어, 결과값이 동일함
- 반환값이 없기 때문에 함수 내부에서 함수의 결과값을 출력함
- 반환값이 없기 대문에 함수의 결과를 외부에서 활용할 수 -
2. 매개변수는 존재하고 반환값은 없는 타입
- 매개변수가 있기 때문에 함수를 실행하는데 필요한 데이터를 함수 외부에서 전달받아 사용함
- 함수 외부에서 데이터가 전달되기 때문에 전달되는 데이터에 따라 함수의 결과가 달라짐
- 반환값이 없기 때문에 함수 내부에서 함수의 결과값을 출력함
- 반환값이 없기 대문에 함수의 결과를 외부에서 활용할 수 -
3. 매개변수는 없고 반환값은 존재하는 타입
- 매개변수가 없기 때문에 함수를 실행하는데 필요한 변수를 함수 내부에서 모두 선언하고 사용하고 삭제함
- 함수 내부에서 변수가 선언되고 사용되기 때문에 데이터가 고정되어 있어, 결과값이 동일함
- 반환값이 존재하기 때문에 함수 내부에서 함수의 결과를 출력할 필요가 없음
- 반환값이 존재하기 때문에 함수의 결과를 외부에서 활용할 수 -
4. 매개변수와 반환값이 모두 존재하는 타입
- 매개변수가 있기 때문에 함수를 실행하는데 필요한 데이터를 함수 외부에서 전달받아 사용함
- 함수 외부에서 데이터가 전달되기 때문에 전달되는 데이터에 따라 함수의 결과가 달라짐
- 반환값이 존재하기 때문에 함수 내부에서 함수의 결과를 출력할 필요가 없음
- 반환값이 존재하기 때문에 함수의 결과를 외부에서 활용할 수 있음
